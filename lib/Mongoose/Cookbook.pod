
=pod

=head1 NAME

Mongoose::Cookbook - recipes, recipes

=head1 RECIPES

Here we go.

=head2 Connecting to MongoDB

First connect to a database before starting to use your classes. 

    use Mongoose;
    Mongoose->db( 'mydb'); # looks for a localhost connection

    # or, for more control:

    Mongoose->db(
        host=>'mongodb://data.server:4000',
        db_name=>'mydb'
    );           

This is done globally here for simplicity sake, but multiple
connections and databases are also supported. 

=head2 Connecting to more than one database

This is a work in progress. Right now this syntax is supported:

    Mongoose->db( class=>'Person', db_name=>'mydbone', ... );
    Mongoose->db( class=>'Address', db_name=>'mydbtwo', ... );

This is quite rudimentary, and will probably change in the future.

=head2 Loading a Schema

To quickly load your Mongoose classes (or any kind of 
package for that matter), use the C<load_schema> method:

    package main;
    Mongoose->load_schema( search_path=>'MyApp::Schema', shorten=>1 );

Use it only once in your program. Your modules will be C<require>d
and may be used from anywhere else. 

If set to 1, the C<shorten> option will alias C<MyApp::Schema::MyClass>
into C<MyClass> for convenience.

=head2 Preventing attributes from being stored

In case your class has attributes you don't want to store in the database.

    package Person;
    use Moose;
    with 'Mongoose::Document';

    has 'name' => ( is => 'rw', isa => 'Str', required => 1 );
    has 'age'  => ( is => 'rw', isa => 'Int', default  => 40 );
    has 'salary' => ( is => 'rw', isa => 'Int', traits => ['DoNotSerialize'] );

=head2 One-to-many Relationships

This can be accomplished several ways. 

=head3 ArrayRef

Use the C<ArrayRef> Moose type.

    package Person;
    use Moose;
    with 'Mongoose::Document';

    has 'name' => ( is => 'rw', isa => 'Str', required => 1 );
    has 'accounts'  => ( is => 'rw', isa => 'ArrayRef[Account]' );

Then, define the Account class, either as a document or embedded document, 
depending on how you want it stored.

    package Address;
    use Moose;
    with Mongoose::EmbeddedDocument;

    has 'amount' => ...;

But this has a memory and performance cost, since all related rows
will be loaded in memory during object expansion.

To avoid loading related rows, use a L<Mongoose::Join>
parameterized type. 

=head3 Mongoose::Join

Establishing a Mongoose::Join relationship will load relationships
lazily:

    package Person;
    use Moose; with 'Mongoose::Document';

    has 'name' => ( is => 'rw', isa => 'Str', required => 1 );
    has 'accounts'  => ( is => 'rw', isa => 'Mongoose::Join[Account]' );

Then retrieve data with a cursor:

    my $large_acc = $person->accounts->find({ amount => { '$gt' => 100000 } });
    while( my $account = $large_acc->next ) {
        ...
    }

=head2 Sugar for Defining Relationships

Use L<Mongoose::Class> instead of C<Moose>.

    package Article;
    use Mongoose::Class; with 'Mongoose::Document';
    has 'title' => ( is=>'rw', isa=>'Str', required=>1 );
    has_one 'author' => 'Author'; 
    has_many 'comments' => 'Comment'; 
    belongs_to => 'Account';

=head2 Normalizing a Relationship

Normalization is a relational concept, not natural to the
document-oriented MongoDB, but an useful approach that
should sometimes be taken into consideration. 

Sometimes it may just be more adequate than storing relationships
directly in objects:

    package Authorship;
    use Mongoose::Class; with 'Mongoose::Document';

    has_one 'author' => 'Author';
    has_many 'articles' => 'Article';

    # or even:
    #  has_one 'article' => 'Article';

    package main;

    # create

    my $authorship = Authorship->new;
    $authorship->author( Author->new );
    $authorship->articles->add( Article->new );
    $authorship->articles->add( Article->new );

    # find

    my $articles = Authorship->find_one({ author=>$author->_id });
    while( my $article = $articles->next ) {
        ...
    }

=head2 Package aliasing

To make a long package name shorter, use:

    package My::Mumbo::Jumbo::Class;
    with 'Mongoose::Document' => {
        -as    => 'Mumbo',
    };

    # then in your code

    my $obj = Mumbo->find_one({ flavor=>'gum' })

    print ref $obj;
    # prints 'My::Mumbo::Jumbo::Class'

    print $obj->isa('Mumbo')
    # prints 1

=head2 Method aliasing

In case you don't want a C<find_one> or C<save> method
polluting your class.

    package BankAccount;
    with 'Mongoose::Document' => {
        -alias    => { 'find_one' => '_find_one' },
        -excludes => { 'find_one' },
    };

=head2 Paging and Sorting

Just use MongoDB's C<query> standard syntax:

    # sorting

    my $sorted = Person->query( {}, { sort_by => { name => 1 } } )->each(
        sub {
            my $person = shift;
            print $person->name;
        }
    );

    # paging

    my $paged = Person->query(
        {},
        {
            sort_by => { name => 1 },
            limit   => 20,
            skip    => 40
        }
      )->each(
        sub {
            my $person = shift;
            print $person->name;
        }
      );

=head2 Direct access to MongoDB Calls

To skip Mongoose and have direct access to MongoDB, use the
C<db> and C<collection> methods on your class: 

    # finds and expands documents into objects

    my $cur = Person->find;
    
    # or just get the plain documents (hashrefs)

    my $cur = Person->collection->find;

    # get the MongoDB::Database object for your class

    my $db = Person->db;
    $db->run_command({ shutdown => 1 });

This can be useful for performance reasons, when you 
don't need to expand objects, or need to access
MongoDB functionality not available in Mongoose. It's also 
useful for testing, to compare if some set of query results
returned by Mongoose are identical to the straight MongoDB
driver's results. 

=cut
